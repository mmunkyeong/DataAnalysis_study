### Section3. 기본 데이터 구조 개괄(리스트, 튜플, 딕셔너리, 셋)

<br>

## 리스트/튜플/셋/딕셔너리 📚
### 리스트 List

- 리스트는 숫자, 문자, Boolean 데이터 타입이 순서대로 들어가 있는 데이터 구조
- 원소를 수정할 수 있다는 특징이 있음

<br>

### 튜플 Tuple

- 튜플은 리스트와 같이 기본 데이터 타입이 순서대로 들어가 있는 데이터 구조

- 튜플에서는 원소를 수정할 수 없다는 것이 리스트와 다른점

<br>

### 셋 Set

- 셋은 기본 데이터 타입이 순서가 없이 들어가 있는 데이터 구조
- 셋에서는 원소의 중복을 허용하지 않음

<br>

### 딕셔너리 Dictionary

- 키Key와 Value의 쌍으로 이루어진 원소를 가진 데이터 구조

<br>

### 기본 데이터 구조 특징

| 기본 데이터 구조 | 순서 있음 | 수정가능 |
| --- | --- | --- |
| 리스트 List | O | O |
| 튜플 Tuple | O | X |
| 셋 Set | X | O |
| 딕셔너리 Dictionary | X | O |

<br>

## 리스트(List)

### 1. 리스트 요소 추가하기

`append`와 `insert`를 사용해 리스트에 원소를 추가할 수 있음

- append를 사용하면 리스트의 맨 끝에 값을 추가할 수 있음
- insert는 원하는 위치에 값을 추가할 수 있다는 점이 append와 구분

<br>

### 2. 리스트 요소 삭제하기

`remove`와 `del`을 사용하여 요소를 삭제할 수 있음 

### Remove

- remove를 사용하면 리스트에서 특정 값을 찾아서 삭제할 수 있음
- 설정한 값이 리스트에 여러개 있는 경우 가장 앞에 있는 값 하나만 삭제

### Del

- del을 사용하면 해당 인덱스의 값을 삭제할 수 있음
- del은 인덱스를 통해 값을 찾기 때문에 슬라이싱을 이용해 여러 값을 한 번 에 삭제할 수 있음

<br>


### 3. List: 인덱스와 슬라이싱

### 리스트 인덱싱 indexing

- 문자열에서 마찬가지로 [ ] 대괄호 안에 인덱스를 입력하면 해당 원소를 출력
- 정수를 입력하면 앞에서부터, 음수를 입력하면 뒤에서부터 순서를 카운트 함

<br>

### 리스트 슬라이싱 Slicing

- 슬라이싱에서도 정수 인덱스, 음수 인덱스 모두 사용할 수 있음
- 첫번째 값부터 시작할 때는 콜론 `:`앞의 값을 생략할 수 있음
- 특정 값에서 마지막 값까지 슬라이싱해줄 때는 콜론 `:`뒤의 값을 생략할 수 있음

<br>

### Stepping

- 슬라이싱 할 때 step 값만큼 건너뛰고 출력

```python
list[n:m:step]
```

<br>

### 4. List: 정렬하기

### Sort

- 리스트의 값을 오름차순으로 정렬하고 그 값을 원본에 저장
- 숫자, 영어, 한글 모두 정렬 가능

<br>

### Sorted()

- 내장함수를 사용하면 정렬된 값을 출력하며 원본 리스트에는 영향을 주지 않음

<br>


## Tuple

- ( ) 소괄호로 감싸면 튜플
- 튜플은 리스트처럼 순서가 있는 자료구조이지만 한 번 만들어지면 원소를 수정할 수 없다는 것이 리스트와 구분

### 특징

1. 순서가 있음
2. 원소를 수정할 수 없음

<br>

### 1. 튜플끼리 더하기

```python
t = ( "aa", "bb", "cc", "dd")

# 튜플끼리 더하기

sum_t = t + t

# 튜플 반복하기
t * 3
```

<br>

### 2. 특정 원소 포함 여부 확인하기

```python
# 특정 원소 포함여부 확인

'aa' in a
```

<br>

### 3. 튜플의 언패킹 unpacking

```python
# 언패킹할 때는 튜플에 있는 원소의 갯수만큼 변수를 할당
# 언패킹은 리스트도 가능

a1, b1, c1, d1 = t
```

<br>

### 4. 튜플을 리스트로, 리스트를 튜플로

- 튜플과 리스트는 서로 자료구조를 쉽게 변경할 수 있음

```python
# 튜플을 리스트로, 리스트를 튜플로 변경 가능

c = tuple(b)

k = list(a)

# 튜플은 원소를 수정하지 않기 때문에 연산 속도가 더 빠르다는 장점이 있음

```

<br>

## 딕셔너리

- 사전이라는 뜻처럼 키(Key)와 (Value)로 쌍을이루어진 구조

### 1. 데이터 추가

- 원소가 들어 있지 않은 딕셔너리 안에 키-값 쌍을 추가
- 딕셔너리는 순서 즉 인덱스가 없고, 키가 없는 값을, 값이 없는 키를 넣을 수 없음
- append나 insert와 같은 메서드를 지원하지 않음, 명시적으로 키-값 쌍을 넣어야함

 

```python
fruit_color = {}

# 데이터 추가 
fruit_color['바나나'] = '노랑'
fruit_color['포도'] = '보라'
fruit_color['메론'] = '연두'
```

<br>

### 2. 데이터 삭제

```python
del 딕셔너리_이름[삭제할키]
```

<br>

### 3. 키, 값 구하기

- 특정한 값 찾기

```python
딕셔너리_이름[찾는키]
```

<br>

#### keys()

- 키 값만 구하기
- 리스트가 조작이 편하기 때문에 리스트로 형 변환을 해서 자주 사용

```python
# key 값은 list로 변환을 자주 사용

k = list(fruit_color.keys())
```

<br>

#### values()

- 값 목록을 구할 때 사용하는 메서드

```python
# 값 목록을 구할 때 value 메소드를 사용

v = list(fruit_color.values())
```
<br>

#### items()

- 딕셔너리에 있는 데이터들을 모두 뽑아 (키,값)쌍의 dict_items 반환

```python
# 딕셔너리에 있는 데이터들을 모두 뽑아 반환

fruit_color.items()

item = list(fruit_color.items())

# 안에 들어 있는 값은 튜플임

item[0]
```

<br>

### 4. 특정 원소 포함 여부 확인 in/not in

```python
# key 값들 중 찾을 때 

# 특정 원소 포함 여부 확인 (key 중에서만 찾음)

'포도' in fruit_color

# value 값을 찾고 싶다면 values 를 사용

'빨강' in fruit_color.values()
```

<br>

### Dictionary 특징

1. 딕셔너리의 key는 unique 
2. key는 수정할 수 없는 값만 가능
3. 딕셔너리는 순서가 없음

<br>

## Set

### 특징
1. 순서가 없음
2. 중복 허용이 안됨

```python
# 데이터 추가
a.add(5)

# update
# 한 번에 여러개 추가
a.update([4,5,6,7])

# remove
# set은 특정값 제거 가능
a.remove(7)

# clear
# 모든 값을 삭제
a.clear()

#특정 원소 포함 여부 확인 not in, in
a = {1, 2, 3}
b = {3, 4, 5}

1 in a

# 합집합
a|b
a.union(b)

# 교집합
a & b
a.intersection(b)

# 차집합
a - b
a.difference(b)

# 대칭차
a ^ b
a.symmetric_difference(b)

# Set끼리 부분집합 여부 확인
a = {1, 2, 3, 4, 5}
b = {1, 2, 3}

a.issubset(b)
b.issubset(a)

# issuperset
# a가 b를 포함할 때 a.issuperset(b) true 반환

a.issuperset(b)
b.issuperset(a)

# isdisjoint
# 교집합이 없을 때 true 반환

a.isdisjoint(b)
```
